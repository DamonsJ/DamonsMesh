//##########################################################################
//#                                                                        #
//#                              CLOUDCOMPARE                              #
//#                                                                        #
//#  This program is free software; you can redistribute it and/or modify  #
//#  it under the terms of the GNU General Public License as published by  #
//#  the Free Software Foundation; version 2 or later of the License.      #
//#                                                                        #
//#  This program is distributed in the hope that it will be useful,       #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of        #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the          #
//#  GNU General Public License for more details.                          #
//#                                                                        #
//#          COPYRIGHT: EDF R&D / TELECOM ParisTech (ENST-TSI)             #
//#                                                                        #
//##########################################################################

#include "..\include\STLFilter.h"

//System
#include <string.h>

bool STLFilter::canLoadExtension(const std::string& upperCaseExt) const
{
	return (upperCaseExt == "STL");
}

bool STLFilter::canSave(DB_CLASS_ENUM type, bool& multiple, bool& exclusive) const
{
	if (type == DB_TYPES::MESH)
	{
		multiple = false;
		exclusive = true;
		return true;
	}
	return false;
}

CC_FILE_ERROR STLFilter::saveToFile(ModelObject* entity, const std::string& filename, const SaveParameters& parameters)
{
	if (!entity)
		return CC_FERR_BAD_ARGUMENT;

	if (!entity->isA(DB_TYPES::MESH))
		return CC_FERR_BAD_ENTITY_TYPE;

	MeshModel* mesh = static_cast<MeshModel*>(entity);
	if (!mesh || mesh->getTriangleNumber() == 0)
	{
		return CC_FERR_NO_ERROR;
	}

	//ask for output format
	bool binaryMode = true;
	if (parameters.alwaysDisplaySaveDialog)
	{
// 		QMessageBox msgBox(QMessageBox::Question, "Choose output format", "Save in BINARY or ASCII format?");
// 		QPushButton *binaryButton = msgBox.addButton("BINARY", QMessageBox::AcceptRole);
// 		msgBox.addButton("ASCII", QMessageBox::AcceptRole);
// 		msgBox.exec();
// 		binaryMode = (msgBox.clickedButton() == binaryButton);
	}

	//try to open file for saving
	FILE* theFile = fopen(filename.c_str(), "wb");
	if (!theFile)
		return CC_FERR_WRITING;

	CC_FILE_ERROR result = CC_FERR_NO_ERROR;
	if (binaryMode)
	{
		result = saveToBINFile(mesh, theFile);
	}
	else 
	{
		result = saveToASCIIFile(mesh, theFile);
	}

	fclose(theFile);

	return result;
}

CC_FILE_ERROR STLFilter::saveToBINFile(MeshModel* mesh, FILE *theFile, QWidget* parentWidget/*=0*/)
{
	unsigned faceCount = mesh->getTriangleNumber();

	//header
	{
		char header[80];
		memset(header, 0, 80);
		strcpy(header, "Binary STL file generated by CloudCompare!");
		if (fwrite(header, 80, 1, theFile) < 1)
			return CC_FERR_WRITING;
	}

	//UINT32 Number of triangles
	{
		uint32_t tmpInt32 = static_cast<uint32_t>(faceCount);
		if (fwrite((const void*)&tmpInt32, 4, 1, theFile) < 1)
			return CC_FERR_WRITING;
	}

	for (unsigned i = 0; i < faceCount; ++i)
	{
		unsigned int id1, id2, id3;
		mesh->getTriangleIndex(i, id1, id2, id3);

		DGraphic::DPoint<float> p1, p2, p3;
		mesh->getTriangleVertices(id1, p1, p2, p3);
	}

	return CC_FERR_NO_ERROR;
}

CC_FILE_ERROR STLFilter::saveToASCIIFile(MeshModel* mesh, FILE *theFile, QWidget* parentWidget/*=0*/)
{
	return CC_FERR_NO_ERROR;
}

bool STLFilter::IsSTLBinary(const char * filename) {

	bool binaryFlag = false;
	FILE *fp = fopen(filename, "r");
	/* Find size of file */
	fseek(fp, 0, SEEK_END);
	long file_size = ftell(fp);
	unsigned int facenum;
	/* Check for binary or ASCII file */
	fseek(fp, STL_LABEL_SIZE, SEEK_SET);
	fread(&facenum, sizeof(unsigned int), 1, fp);

	// second check, sometimes the size is a bit wrong, 
	// lets'make a test to check that we find only ascii stuff before assuming it is ascii
	unsigned char tmpbuf[1000];
	int byte_to_read = std::min(int(sizeof(tmpbuf)), int(file_size - 80));
	fread(tmpbuf, byte_to_read, 1, fp);
	fclose(fp);
	for (int i = 0; i < byte_to_read; i++)
	{
		if (tmpbuf[i] > 127)
		{
			binaryFlag = true;
			break;
		}
	}
	// Now we know if the stl file is ascii or binary.
	return binaryFlag;
}

CC_FILE_ERROR STLFilter::loadFile(const std::string& filename, ModelObject *&container, LoadParameters& parameters)
{

	bool ascii = IsSTLBinary(filename.c_str());
	MeshModel* mesh = new MeshModel("stl_mesh");
	CC_FILE_ERROR error = CC_FERR_NO_ERROR;
	if (ascii)
		error = loadASCIIFile(filename, mesh, parameters);
	else
		error = loadBinaryFile(filename, mesh, parameters);

	if (error != CC_FERR_NO_ERROR)
	{
		return CC_FERR_MALFORMED_FILE;
	}

	container = mesh;

	return CC_FERR_NO_ERROR;
}

CC_FILE_ERROR STLFilter::loadASCIIFile(std::string filename,
										MeshModel* mesh,
										LoadParameters& parameters)
{
	FILE *fp;
	fp = fopen(filename.c_str(), "r");
	if (fp == nullptr)
	{
		return CC_FERR_READING;
	}
	long currentPos = ftell(fp);
	fseek(fp, 0L, SEEK_END);
	long fileLen = ftell(fp);
	fseek(fp, currentPos, SEEK_SET);

	/* Skip the first line of the file */
	while (getc(fp) != '\n') {}

	struct
	{
		float n[3];
		float v1[3]; 
		float v2[3]; 
		float v3[3];
	} f;

	int cnt = 0;
	int lineCnt = 0;
	int ret;
	/* Read a single facet from an ASCII .STL file */
	while (!feof(fp))
	{
		ret = fscanf(fp, "%*s %*s %f %f %f\n", &f.n[0], &f.n[1], &f.n[2]); // --> "facet normal 0 0 0"
		if (ret != 3)
		{
			lineCnt++;
			continue;
		}
		ret = fscanf(fp, "%*s %*s"); // --> "outer loop"
		ret = fscanf(fp, "%*s %f %f %f\n", &f.v1[0], &f.v1[1], &f.v1[2]); // --> "vertex x y z"
		if (ret != 3)
			return CC_FERR_READING;
		ret = fscanf(fp, "%*s %f %f %f\n", &f.v2[0], &f.v2[1], &f.v2[2]); // --> "vertex x y z"
		if (ret != 3)
			return CC_FERR_READING;
		ret = fscanf(fp, "%*s %f %f %f\n", &f.v3[0], &f.v3[1], &f.v3[2]); // --> "vertex x y z"
		if (ret != 3)
			return CC_FERR_READING;
		ret = fscanf(fp, "%*s"); // --> "endloop"
		ret = fscanf(fp, "%*s"); // --> "endfacet"
		lineCnt += 7;
		if (feof(fp)) break;

		mesh->addPoint(f.v1[0], f.v1[1], f.v1[2]);
		mesh->addPoint(f.v2[0], f.v2[1], f.v2[2]);
		mesh->addPoint(f.v3[0], f.v3[1], f.v3[2]);

		mesh->addNormal(f.n[0], f.n[1], f.n[2]);
		mesh->addNormal(f.n[0], f.n[1], f.n[2]);
		mesh->addNormal(f.n[0], f.n[1], f.n[2]);

		mesh->addTriangle(cnt, cnt + 1, cnt + 2);
		cnt = cnt + 3;
	}
	fclose(fp);
	mesh->refreshBoundBox();
	return CC_FERR_NO_ERROR;
}

CC_FILE_ERROR STLFilter::loadBinaryFile(std::string filename,
										MeshModel* mesh,
										LoadParameters& parameters)
{
	FILE *fp;
	fp = fopen(filename.c_str(), "rb");
	if (fp == nullptr)
	{
		return CC_FERR_READING;
	}

	int facenum;
	fseek(fp, STL_LABEL_SIZE, SEEK_SET);
	fread(&facenum, sizeof(int), 1, fp);

	mesh->ResizePoints(facenum * 3);
	mesh->ResizeTriangles(facenum );
	mesh->ResizeNormals(facenum * 3);

	// For each triangle read the normal, the three coords and a short set to zero
	for (int i = 0; i < facenum; ++i)
	{
		unsigned short attr;
		float norm[3];
		float tri[9];
		fread(&norm, 3 * sizeof(float), 1, fp);
		fread(&tri, 3 * sizeof(float), 3, fp);
		fread(&attr, sizeof(unsigned short), 1, fp);
		
		mesh->setPoint(3 * i, tri[0], tri[1], tri[2]);
		mesh->setPoint(3 * i + 1, tri[3], tri[4], tri[5]);
		mesh->setPoint(3 * i + 2, tri[6], tri[7], tri[8]);

		mesh->setNormal(3 * i, norm[0], norm[1], norm[2]);
		mesh->setNormal(3 * i + 1, norm[0], norm[1], norm[2]);
		mesh->setNormal(3 * i + 2, norm[0], norm[1], norm[2]);

		mesh->setTriangle(i,3 * i, 3 * i + 1, 3 * i + 2);
	}
	fclose(fp);
	mesh->refreshBoundBox();

	return CC_FERR_NO_ERROR;
}

