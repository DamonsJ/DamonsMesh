#include "..\include\PlyFilter.h"

#include <string.h>
#include <assert.h>

#if defined _WIN32
#include <windows.h>
#else
#include <time.h>
#include <unistd.h>
#endif

namespace DamonsIO {

	bool PlyFilter::canLoadExtension(const std::string& upperCaseExt) const
	{
		return (upperCaseExt == "PLY");
	}

	
	static e_ply_storage_mode s_defaultOutputFormat = PLY_DEFAULT;
	void PlyFilter::SetDefaultOutputFormat(e_ply_storage_mode format)
	{
		s_defaultOutputFormat = format;
	}

	DAMONS_FILE_ERROR PlyFilter::saveToFile(DMeshLib::ModelObject* entity, const std::string& filename, const SaveParameters& parameters)
	{
		if (!entity || filename.empty())
			return CC_FERR_BAD_ARGUMENT;

		DMeshLib::MeshModel* mesh = static_cast<DMeshLib::MeshModel*>(entity);
		e_ply_storage_mode storageType = PLY_ASCII;
		p_ply ply = ply_create(filename.c_str(), storageType, nullptr, 0, nullptr);
		if (!ply)
			return CC_FERR_WRITING;

		//Has the cloud been recentered?
		e_ply_type coordType = /*PLY_DOUBLE :*/ PLY_FLOAT; //we use double coordinates for shifted vertices (i.e. >1e6)

		int result = 1;
		unsigned vertCount = mesh->getPointsNumber();

		//3D points (x,y,z)
		if (ply_add_element(ply, "vertex", vertCount))
		{
			result = ply_add_scalar_property(ply, "x", coordType);
			result = ply_add_scalar_property(ply, "y", coordType);
			result = ply_add_scalar_property(ply, "z", coordType);
		}
		else result = 0;

		//Normals (nx,ny,nz)
		bool hasNormals = mesh->hasNormals();
		if (hasNormals)
		{
			e_ply_type normType = /*PLY_DOUBLE : */PLY_FLOAT;
			result = ply_add_scalar_property(ply, "nx", normType);
			result = ply_add_scalar_property(ply, "ny", normType);
			result = ply_add_scalar_property(ply, "nz", normType);
		}

		//Mesh
		unsigned triNum = 0;
		if (mesh)
		{
			triNum = mesh->getTriangleNumber();
			if (triNum > 0 && ply_add_element(ply, "face", triNum))
			{
				//DGM: don't change the field name (vertex_indices) as Meshlab
				//only support this one! (grrrrrrrrr)
				result = ply_add_list_property(ply, "vertex_indices", PLY_UCHAR, PLY_INT);
			}
			else result = 0;
		}
 
		ply_add_obj_info(ply, "Generated by Damons!");

		//try to write header
		result = ply_write_header(ply);
		if (!result)
		{
			ply_close(ply);
			return CC_FERR_WRITING;
		}

		DMeshLib::data_type x, y, z;
		//save the point cloud (=vertices)
		for (unsigned i = 0; i < vertCount; ++i)
		{
			mesh->getPoint(i, x, y, z);
			ply_write(ply, x);
			ply_write(ply, y);
			ply_write(ply, z);

			if (hasNormals)
			{
				/*mesh->getPointNormal(i);
				ply_write(ply, static_cast<double>(N.x));
				ply_write(ply, static_cast<double>(N.y));
				ply_write(ply, static_cast<double>(N.z));*/
			}
		}

		//and the mesh structure
		if (mesh)
		{
			DMeshLib::index_type id1, id2, id3;
			for (unsigned i = 0; i < triNum; ++i)
			{
				mesh->getTriangleIndex(i,id1,id2,id3); //DGM: getNextTriangleVertIndexes is faster for mesh groups!
				ply_write(ply, double(3));
				assert(id1 < vertCount);
				assert(id2 < vertCount);
				assert(id3 < vertCount);
				ply_write(ply, double(id1));
				ply_write(ply, double(id2));
				ply_write(ply, double(id3));

			}
		}

		ply_close(ply);

		return CC_FERR_NO_ERROR;
	}

#define PROCESS_EVENTS_FREQ 10000

#define ELEM_POS_0	0x00000000
#define ELEM_POS_1	0x00000001
#define ELEM_POS_2	0x00000002
#define ELEM_POS_3	0x00000003
#define ELEM_EOL	0x00000004

#define POS_MASK	0x00000003

	static int s_PointCount = 0;
	static int s_NormalCount = 0;
	static int s_ColorCount = 0;
	static int s_IntensityCount = 0;
	static unsigned s_totalScalarCount = 0;
	static unsigned s_triCount = 0;
	static bool s_PointDataCorrupted = false;
	static bool s_NotEnoughMemory = false;
	static FileIOFilter::LoadParameters s_loadParameters;
	bool s_hasQuads = false;
	bool s_hasMaterials = false;
	std::vector<bool> s_triIsQuad;

	static int vertex_cb(p_ply_argument argument)
	{
		if (s_NotEnoughMemory)
		{
			//skip the next pieces of data
			return 1;
		}
		long flags;
		DMeshLib::MeshModel* mesh;
		ply_get_argument_user_data(argument, (void**)(&mesh), &flags);

		double val = ply_get_argument_value(argument);

		static DMeshLib::data_type s_Point[3];

		// This looks like it should always be true, 
		// but it's false if x is NaN.
		if (val == val)
		{
			s_Point[flags & POS_MASK] = val;
		}
		else
		{
			//warning: corrupted data!
			s_PointDataCorrupted = true;
			s_Point[flags & POS_MASK] = 0;
		}

		if (flags & ELEM_EOL)
		{
			mesh->addPoint(s_Point[0], s_Point[1], s_Point[2]);
			++s_PointCount;

			s_PointDataCorrupted = false;
		}

		return 1;
	}

	static int normal_cb(p_ply_argument argument)
	{
		if (s_NotEnoughMemory)
		{
			//skip the next pieces of data
			return 1;
		}
		long flags;
		DMeshLib::MeshModel* mesh;
		ply_get_argument_user_data(argument, (void**)(&mesh), &flags);

		static DMeshLib::data_type s_Normal[3];
		s_Normal[flags & POS_MASK] = static_cast<DMeshLib::data_type>(ply_get_argument_value(argument));

		if (flags & ELEM_EOL)
		{
			mesh->addNormal(s_Normal[0], s_Normal[1], s_Normal[2]);
			++s_NormalCount;
		}

		return 1;
	}

	static int rgb_cb(p_ply_argument argument)
	{
		// not support rgb segment
		/*if (s_NotEnoughMemory)
		{
			//skip the next pieces of data
			return 1;
		}
		long flags;
		DMeshLib::MeshModel* mesh;
		ply_get_argument_user_data(argument, (void**)(&mesh), &flags);

		p_ply_property prop;
		ply_get_argument_property(argument, &prop, nullptr, nullptr);
		e_ply_type type;
		ply_get_property_info(prop, nullptr, &type, nullptr, nullptr);

		static double s_color[3];

		switch (type)
		{
		case PLY_FLOAT:
		case PLY_DOUBLE:
		case PLY_FLOAT32:
		case PLY_FLOAT64:
			s_color[flags & POS_MASK] = static_cast<double>(std::min(std::max(0.0, ply_get_argument_value(argument)), 1.0) * ccColor::MAX);
			break;
		case PLY_INT8:
		case PLY_UINT8:
		case PLY_CHAR:
		case PLY_UCHAR:
			s_color[flags & POS_MASK] = static_cast<double>(ply_get_argument_value(argument));
			break;
		default:
			s_color[flags & POS_MASK] = static_cast<double>(ply_get_argument_value(argument));
			break;
		}

		if (flags & ELEM_EOL)
		{
			mesh->addRGBColor(s_color);
			++s_ColorCount;

		}*/

		return 1;
	}

	static int grey_cb(p_ply_argument argument)
	{
		// not support grey-color segment
		/*if (s_NotEnoughMemory)
		{
			//skip the next pieces of data
			return 1;
		}
		DMeshLib::MeshModel* mesh;
		ply_get_argument_user_data(argument, (void**)(&mesh), nullptr);

		p_ply_property prop;
		ply_get_argument_property(argument, &prop, nullptr, nullptr);
		e_ply_type type;
		ply_get_property_info(prop, nullptr, &type, nullptr, nullptr);

		double G;

		switch (type)
		{
		case PLY_FLOAT:
		case PLY_DOUBLE:
		case PLY_FLOAT32:
		case PLY_FLOAT64:
			G = static_cast<double>(std::min(std::max(0.0, ply_get_argument_value(argument)), 1.0) * ccColor::MAX);
			break;
		case PLY_INT8:
		case PLY_UINT8:
		case PLY_CHAR:
		case PLY_UCHAR:
			G = static_cast<double>(ply_get_argument_value(argument));
			break;
		default:
			G = static_cast<double>(ply_get_argument_value(argument));
			break;
		}

		cloud->addGreyColor(G);
		++s_IntensityCount;
		*/
		return 1;
	}

	static int scalar_cb(p_ply_argument argument)
	{
		/*if (s_NotEnoughMemory)
		{
			//skip the next pieces of data
			return 1;
		}
		CCLib::ScalarField* sf = 0;
		ply_get_argument_user_data(argument, (void**)(&sf), nullptr);

		p_ply_element element;
		long instance_index;
		ply_get_argument_element(argument, &element, &instance_index);

		ScalarType scal = static_cast<ScalarType>(ply_get_argument_value(argument));
		sf->setValue(instance_index, scal);
		*/

		return 1;
	}

	static bool s_unsupportedPolygonType = false;
	static int face_cb(p_ply_argument argument)
	{
		if (s_NotEnoughMemory)
		{
			//skip the next pieces of data
			return 1;
		}
		DMeshLib::MeshModel* mesh = 0;
		ply_get_argument_user_data(argument, (void**)(&mesh), nullptr);
		if (!mesh)
		{
			assert(false);
			return 1;
		}

		long length, value_index;
		ply_get_argument_property(argument, nullptr, &length, &value_index);
		//unsupported polygon type!
		if (length != 3 && length != 4)
		{
			s_unsupportedPolygonType = true;
			return 1;
		}
		if (value_index < 0 || value_index + 1 > length)
		{
			return 1;
		}

		static DMeshLib::index_type s_tri[4];
		s_tri[value_index] = static_cast<unsigned>(ply_get_argument_value(argument));

		if (value_index < 2)
		{
			return 1;
		}

		if (value_index == 2)
		{
			mesh->addTriangle(s_tri[0], s_tri[1], s_tri[2]);
			++s_triCount;
		}
		else if (value_index == 3)
		{
			s_hasQuads = true;
			mesh->addTriangle(s_tri[0], s_tri[2], s_tri[3]);
			++s_triCount;
		}

		return 1;
	}

	static unsigned s_texCoordCount = 0;
	static bool s_invalidTexCoordinates = false;
	static int texCoords_cb(p_ply_argument argument)
	{
		/*if (s_NotEnoughMemory)
		{
			//skip the next pieces of data
			return 1;
		}

		long length, value_index;
		ply_get_argument_property(argument, nullptr, &length, &value_index);
		//unsupported/invalid coordinates!
		if (length != 6 && length != 8)
		{
			s_invalidTexCoordinates = true;
			return 1;
		}
		if (value_index < 0 || value_index + 1 > length)
		{
			return 1;
		}

		static float s_texCoord[8];
		s_texCoord[value_index] = static_cast<float>(ply_get_argument_value(argument));

		if (((value_index + 1) % 2) == 0)
		{
			TextureCoordsContainer* texCoords = 0;
			ply_get_argument_user_data(argument, (void**)(&texCoords), nullptr);
			assert(texCoords);
			if (!texCoords)
				return 1;

			if (texCoords->currentSize() == texCoords->capacity())
			{
				if (!texCoords->reserveSafe(texCoords->currentSize() + 1024))
				{
					s_NotEnoughMemory = true;
					return 0;
				}
			}
			texCoords->addElement(TexCoords2D(s_texCoord[value_index - 1], s_texCoord[value_index]));
			++s_texCoordCount;
		}*/

		return 1;
	}

	static int s_maxTextureIndex = -1;
	static int texIndexes_cb(p_ply_argument argument)
	{
		/*p_ply_element element;
		long instance_index;
		ply_get_argument_element(argument, &element, &instance_index);

		int index = static_cast<int>(ply_get_argument_value(argument));
		if (index > s_maxTextureIndex)
		{
			s_maxTextureIndex = -1;
		}

		ccMesh::triangleMaterialIndexesSet* texIndexes = 0;
		ply_get_argument_user_data(argument, (void**)(&texIndexes), nullptr);
		assert(texIndexes);
		if (!texIndexes)
		{
			return 1;
		}
		texIndexes->addElement(index);

		if ((texIndexes->currentSize() % PROCESS_EVENTS_FREQ) == 0)
			QCoreApplication::processEvents();
		*/

		return 1;
	}


	DAMONS_FILE_ERROR PlyFilter::loadFile(const std::string& filename, DMeshLib::ModelObject *&container, LoadParameters& parameters) 
	{
		//reset statics!
		s_triCount = 0;
		s_unsupportedPolygonType = false;
		s_texCoordCount = 0;
		s_invalidTexCoordinates = false;
		s_totalScalarCount = 0;
		s_IntensityCount = 0;
		s_ColorCount = 0;
		s_NormalCount = 0;
		s_PointCount = 0;
		s_PointDataCorrupted = false;
		s_NotEnoughMemory = false;
		s_loadParameters = parameters;
		s_hasQuads = false;
		s_hasMaterials = false;
		s_triIsQuad.clear();

		/****************/
		/***  Header  ***/
		/****************/

		//open a PLY file for reading
		p_ply ply = ply_open(filename.c_str(), nullptr, 0, nullptr);
		if (!ply)
			return CC_FERR_READING;

		if (!ply_read_header(ply))
		{
			ply_close(ply);
			return CC_FERR_WRONG_FILE_TYPE;
		}

		//storage mode: little/big endian
		e_ply_storage_mode storage_mode;
		get_plystorage_mode(ply, &storage_mode);

		/******************/
		/***  Comments  ***/
		/******************/
		{
			//display comments
			const char* lastComment = nullptr;
			while ((lastComment = ply_get_next_comment(ply, lastComment)))
			{
				//specific case: TextureFile 'filename.ext'
				/*if (std::string(lastComment).toUpper().startsWith("TEXTUREFILE "))
				{
					textureFileNames << QString(lastComment).mid(12).trimmed();
				}*/
			}
		}

		//external texture filename?
		/*if (!inputTextureFilename.isEmpty())
		{
			//add it to the set of textures (if it's not already there!)
			if (!textureFileNames.contains(inputTextureFilename))
			{
				textureFileNames.push_back(inputTextureFilename);
			}
		}*/

		/*******************************/
		/***  Elements & properties  ***/
		/*******************************/

		//Point-based elements (points, colors, normals, etc.)
		std::vector<plyElement> pointElements;
		//Mesh-based elements (vertices, etc.)
		std::vector<plyElement> meshElements;

		//Point-based element properties (coordinates, color components, etc.)
		std::vector<plyProperty> stdProperties;
		//Mesh-based multi-element properties (vertex indexes, etc.)
		std::vector<plyProperty> listProperties;
		//Mesh-based single-element properties (texture index, etc.)
		std::vector<plyProperty> singleProperties;

		try
		{
			//last read element
			plyElement lastElement;
			lastElement.elem = 0;
			while ((lastElement.elem = ply_get_next_element(ply, lastElement.elem)))
			{
				//we get next element info
				ply_get_element_info(lastElement.elem, &lastElement.elementName, &lastElement.elementInstances);

				if (lastElement.elementInstances == 0)
				{
					continue;
				}

				lastElement.properties.clear();
				lastElement.propertiesCount = 0;
				lastElement.isFace = false;
				//printf("Element: %s\n",lastElement.elementName);

				//last read property
				plyProperty lastProperty;
				lastProperty.prop = 0;
				lastProperty.elemIndex = 0;

				while ((lastProperty.prop = ply_get_next_property(lastElement.elem, lastProperty.prop)))
				{
					//we get next property info
					ply_get_property_info(lastProperty.prop, &lastProperty.propName, &lastProperty.type, &lastProperty.length_type, &lastProperty.value_type);

					if (lastProperty.type == 16) //PLY_LIST
					{
						lastElement.isFace = true;
					}

					lastElement.properties.push_back(lastProperty);
					++lastElement.propertiesCount;
				}

				//if we have a "face-like" element
				if (lastElement.isFace)
				{
					//we store its properties in 'listProperties'
					for (size_t i = 0; i < lastElement.properties.size(); ++i)
					{
						plyProperty& prop = lastElement.properties[i];
						prop.elemIndex = static_cast<int>(meshElements.size());

						if (prop.type == 16)
						{
							//multiple elements per face (vertex indexes, texture coordinates, etc.)
							listProperties.push_back(prop);
						}
						else
						{
							//single element per face (texture index, etc.)
							singleProperties.push_back(prop);
						}
					}
					meshElements.push_back(lastElement);
				}
				else //else if we have a "point-like" element
				{
					//we store its properties in 'stdProperties'
					for (size_t i = 0; i < lastElement.properties.size(); ++i)
					{
						plyProperty& prop = lastElement.properties[i];
						prop.elemIndex = (int)pointElements.size();
						stdProperties.push_back(prop);
					}
					pointElements.push_back(lastElement);
				}
			}
		}
		catch (const std::bad_alloc&)
		{
			//not enough memory
			return CC_FERR_NOT_ENOUGH_MEMORY;
		}

		//We need some points at least!
		if (pointElements.empty())
		{
			ply_close(ply);
			return CC_FERR_NO_LOAD;
		}

		/**********************/
		/***  Objects info  ***/
		/**********************/
		{
			const char* lastObjInfo = nullptr;
			while ((lastObjInfo = ply_get_next_obj_info(ply, lastObjInfo)))
			{
				std::cout << "[PLY][Info] " << lastObjInfo << std::endl;;
			}
		}

		//properties indexes (0 = unassigned)
		static const unsigned nStdProp = 10;
		int stdPropIndexes[nStdProp] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
		int& xIndex = stdPropIndexes[0];
		int& yIndex = stdPropIndexes[1];
		int& zIndex = stdPropIndexes[2];
		int& nxIndex = stdPropIndexes[3];
		int& nyIndex = stdPropIndexes[4];
		int& nzIndex = stdPropIndexes[5];
		int& rIndex = stdPropIndexes[6];
		int& gIndex = stdPropIndexes[7];
		int& bIndex = stdPropIndexes[8];
		int& iIndex = stdPropIndexes[9];

		std::vector<int> sfPropIndexes;

		static const unsigned nListProp = 2;
		int listPropIndexes[nListProp] = { 0, 0 };
		int& facesIndex = listPropIndexes[0];
		int& texCoordsIndex = listPropIndexes[1];

		static const unsigned nSingleProp = 1;
		int singlePropIndexes[nSingleProp] = { 0 };
		int& texNumberIndex = singlePropIndexes[0];

		{
			for (int i = 1; i <= static_cast<int>(stdProperties.size()); ++i)
			{
				plyProperty& pp = stdProperties[i - 1];
				assert(pp.type != 16); //we don't want any PLY_LIST here
			
				std::string elementName = std::string(pointElements[pp.elemIndex].elementName);
				std::string propName = std::string(pp.propName);

				std::transform(elementName.begin(), elementName.end(), elementName.begin(), ::toupper);
				std::transform(propName.begin(), propName.end(), propName.begin(), ::toupper);

				if (nxIndex == 0 && (std::string::npos !=propName.find("NX") || (std::string::npos != elementName.find("NORM") && propName.back()=='X')))
					nxIndex = i;
				else if (nyIndex == 0 && (std::string::npos != propName.find("NY") || (std::string::npos != elementName.find("NORM") && propName.back() == 'Y')))
					nyIndex = i;
				else if (nzIndex == 0 && (std::string::npos != propName.find("NZ") || (std::string::npos != elementName.find("NORM") && propName.back() == 'Z')))
					nzIndex = i;
				else if (rIndex == 0 && (std::string::npos != propName.find("RED") || (std::string::npos != elementName.find("COL") && propName.back() == 'R')))
					rIndex = i;
				else if (gIndex == 0 && (std::string::npos != propName.find("GREEN") || (std::string::npos != elementName.find("COL") && propName.back() == 'G')))
					gIndex = i;
				else if (bIndex == 0 && (std::string::npos != propName.find("BLUE") || (std::string::npos != elementName.find("COL") && propName.back() == 'B')))
					bIndex = i;
				else if (iIndex == 0 && (std::string::npos != propName.find("INTENSITY") || std::string::npos != propName.find("GRAY") || std::string::npos != propName.find("GREY") || (std::string::npos != elementName.find("COL") && propName.back() == 'I')))
					//iIndex = i; //DGM: we don't load the intensities as RGB colors anymore!
					sfPropIndexes.push_back(i);
				else if (std::string::npos != elementName.find("VERT") || std::string::npos != elementName.find("POINT"))
				{
					if (std::string::npos != propName.find("SCAL"))
						sfPropIndexes.push_back(i);
					else if (xIndex == 0 && propName.back() == 'X')
						xIndex = i;
					else if (yIndex == 0 && propName.back() == 'Y')
						yIndex = i;
					else if (zIndex == 0 && propName.back() == 'Z')
						zIndex = i;
				}
				else if (std::string::npos != propName.find("SCAL") || std::string::npos != propName.find("VAL"))
					sfPropIndexes.push_back(i);
			}
		}


		/*************************/
		/***  Callbacks setup  ***/
		/*************************/

		//Main point cloud
		DMeshLib::MeshModel* mesh = new DMeshLib::MeshModel("unnamed-mesh");

		/* POINTS (X,Y,Z) */
		unsigned numberOfPoints = 0;
		assert(xIndex != yIndex && xIndex != zIndex && yIndex != zIndex);
		//POINTS (X)
		if (xIndex > 0)
		{
			long flags = ELEM_POS_0; //X coordinate
				flags |= ELEM_EOL;

			plyProperty& pp = stdProperties[xIndex - 1];
			ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, vertex_cb, mesh, flags);

			numberOfPoints = pointElements[pp.elemIndex].elementInstances;
		}

		//POINTS (Y)
		if (yIndex > 0)
		{
			long flags = ELEM_POS_1; //Y coordinate
			if (yIndex > xIndex && yIndex > zIndex)
				flags |= ELEM_EOL;

			plyProperty& pp = stdProperties[yIndex - 1];
			ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, vertex_cb, mesh, flags);

			if (numberOfPoints > 0)
			{
				if (static_cast<long>(numberOfPoints) != pointElements[pp.elemIndex].elementInstances)
				{
					delete mesh;
					mesh = nullptr;
					ply_close(ply);
					return CC_FERR_BAD_ENTITY_TYPE;
				}
			}
			else numberOfPoints = pointElements[pp.elemIndex].elementInstances;
		}

		//POINTS (Z)
		if (zIndex > 0)
		{
			long flags = ELEM_POS_2; //Z coordinate
			if (zIndex > xIndex && zIndex > yIndex)
				flags |= ELEM_EOL;

			plyProperty& pp = stdProperties[zIndex - 1];
			ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, vertex_cb, mesh, flags);

			if (numberOfPoints > 0)
			{
				if (static_cast<long>(numberOfPoints) != pointElements[pp.elemIndex].elementInstances)
				{
					delete mesh;
					ply_close(ply);
					return CC_FERR_BAD_ENTITY_TYPE;
				}
			}
			else 
				numberOfPoints = pointElements[pp.elemIndex].elementInstances;
		}

		if (numberOfPoints == 0)
		{
			delete mesh;
			ply_close(ply);
			return CC_FERR_NOT_ENOUGH_MEMORY;
		}

		/* NORMALS (X,Y,Z) */

		unsigned numberOfNormals = 0;

		assert(nxIndex == 0 || (nxIndex != nyIndex && nxIndex != nzIndex));
		assert(nyIndex == 0 || (nyIndex != nxIndex && nyIndex != nzIndex));
		assert(nzIndex == 0 || (nzIndex != nxIndex && nzIndex != nyIndex));

		//NORMALS (X)
		if (nxIndex > 0)
		{
			long flags = ELEM_POS_0; //Nx
			if (nxIndex > nyIndex && nxIndex > nzIndex)
				flags |= ELEM_EOL;

			plyProperty& pp = stdProperties[nxIndex - 1];
			ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, normal_cb, mesh, flags);

			numberOfNormals = pointElements[pp.elemIndex].elementInstances;
		}

		//NORMALS (Y)
		if (nyIndex > 0)
		{
			long flags = ELEM_POS_1; //Ny
			if (nyIndex > nxIndex && nyIndex > nzIndex)
				flags |= ELEM_EOL;

			plyProperty& pp = stdProperties[nyIndex - 1];
			ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, normal_cb, mesh, flags);

			numberOfNormals = std::max(numberOfNormals, (unsigned)pointElements[pp.elemIndex].elementInstances);
		}

		//NORMALS (Z)
		if (nzIndex > 0)
		{
			long flags = ELEM_POS_2; //Nz
			if (nzIndex > nxIndex && nzIndex > nyIndex)
				flags |= ELEM_EOL;

			plyProperty& pp = stdProperties[nzIndex - 1];
			ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, normal_cb, mesh, flags);
			numberOfNormals = std::max(numberOfNormals, (unsigned)pointElements[pp.elemIndex].elementInstances);
		}

		//We check that the number of normals corresponds to the number of points
		if (numberOfNormals > 0)
		{
			if (numberOfPoints != numberOfNormals)
			{
				delete mesh;
				ply_close(ply);
				return CC_FERR_BAD_ENTITY_TYPE;
			}
		}

		/* COLORS (R,G,B) */

		unsigned numberOfColors = 0;

		assert(rIndex == 0 || (rIndex != gIndex && rIndex != bIndex));
		assert(gIndex == 0 || (gIndex != rIndex && gIndex != bIndex));
		assert(bIndex == 0 || (bIndex != rIndex && bIndex != gIndex));

		if (rIndex > 0)
		{
			long flags = ELEM_POS_0; //R
			if (rIndex > gIndex && rIndex > bIndex)
				flags |= ELEM_EOL;

			plyProperty& pp = stdProperties[rIndex - 1];
			ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, rgb_cb, mesh, flags);

			numberOfColors = pointElements[pp.elemIndex].elementInstances;
		}

		if (gIndex > 0)
		{
			long flags = ELEM_POS_1; //G
			if (gIndex > rIndex && gIndex > bIndex)
				flags |= ELEM_EOL;

			plyProperty& pp = stdProperties[gIndex - 1];
			ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, rgb_cb, mesh, flags);

			numberOfColors = std::max(numberOfColors, (unsigned)pointElements[pp.elemIndex].elementInstances);
		}

		if (bIndex > 0)
		{
			long flags = ELEM_POS_2; //B
			if (bIndex > rIndex && bIndex > gIndex)
				flags |= ELEM_EOL;

			plyProperty& pp = stdProperties[bIndex - 1];
			ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, rgb_cb, mesh, flags);

			numberOfColors = std::max(numberOfColors, (unsigned)pointElements[pp.elemIndex].elementInstances);
		}

		/* Intensity (I) */

		//INTENSITE (G)
		if (iIndex > 0)
		{
			if (numberOfColors <= 0)
			{
				plyProperty pp = stdProperties[iIndex - 1];
				ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, grey_cb, mesh, 0);

				numberOfColors = pointElements[pp.elemIndex].elementInstances;
			}
		}

		//We check that the number of colors corresponds to the number of points
		if (numberOfColors > 0)
		{
			if (numberOfPoints != numberOfColors)
			{
				delete mesh;
				ply_close(ply);
				return CC_FERR_BAD_ENTITY_TYPE;
			}
		}

		/* SCALAR FIELDS (SF) */
		/*
		{
			for (size_t i = 0; i < sfPropIndexes.size(); ++i)
			{
				int sfIndex = sfPropIndexes[i];
				plyProperty& pp = stdProperties[sfIndex - 1];

				unsigned numberOfScalars = pointElements[pp.elemIndex].elementInstances;

				//does the number of scalars matches the number of points?
				if (numberOfPoints == numberOfScalars)
				{
					std::string qPropName(pp.propName);
					if (qPropName.startsWith("scalar_") && qPropName.length() > 7)
					{
						//remove the 'scalar_' prefix added when saving SF with CC!
						qPropName = qPropName.mid(7).replace('_', ' ');
					}

					int sfIdx = cloud->addScalarField(qPrintable(qPropName));
					if (sfIdx >= 0)
					{
						CCLib::ScalarField* sf = cloud->getScalarField(sfIdx);
						assert(sf);
						if (sf->resizeSafe(numberOfScalars))
						{
							ply_set_read_cb(ply, pointElements[pp.elemIndex].elementName, pp.propName, scalar_cb, sf, 1);
						}
						else
						{
							cloud->deleteScalarField(sfIdx);
							sfIdx = -1;
						}
					}

					if (sfIdx < 0)
					{
						ccLog::Error(QString("Scalar field #%1: not enough memory to load scalar field (they will be ignored)!").arg(i + 1));
						ccLog::Warning(QString("[PLY] Scalar field #%1 ignored!").arg(i + 1));
					}
				}
			}
		}
		*/
		/* MESH FACETS (TRI) */

		unsigned numberOfFacets = 0;

		if (facesIndex > 0)
		{
			plyProperty& pp = listProperties[facesIndex - 1];
			assert(pp.type == 16); //we only accept PLY_LIST here!
			numberOfFacets = meshElements[pp.elemIndex].elementInstances;
			ply_set_read_cb(ply, meshElements[pp.elemIndex].elementName, pp.propName, face_cb, mesh, 0);
		}

		//let 'Rply' do the job;)
		int success = 0;
		try
		{
			success = ply_read(ply);
		}
		catch (...)
		{
			success = -1;
		}

		ply_close(ply);

		
		if (success < 1 || s_NotEnoughMemory)
		{
			if (mesh)
				delete mesh;
			return CC_FERR_READING;
		}

		//we check mesh
		if (mesh)
		{
			if (mesh->getTriangleNumber() == 0)
			{
				if (s_unsupportedPolygonType)
				{
					std::cout<<"Mesh is not triangular! (unsupported)"<<std::endl;
				}
				else
				{
					std::cout << "Mesh is empty!" << std::endl;
				}
				delete mesh;
				mesh = 0;
			}
			else
			{
				if (s_unsupportedPolygonType)
				{
					std::cout << "Some facets are not triangular! (unsupported)" << std::endl;
				}
			}
		}

		//we save parameters
		parameters = s_loadParameters;

		//we update the scalar field(s)
		/*
		{
			for (unsigned i = 0; i < cloud->getNumberOfScalarFields(); ++i)
			{
				CCLib::ScalarField* sf = cloud->getScalarField(i);
				assert(sf);
				sf->computeMinAndMax();
				if (i == 0)
				{
					cloud->setCurrentDisplayedScalarField(0);
					cloud->showSF(true);
				}
			}
		}*/
		if (mesh) {
			mesh->refreshBoundBox();
			mesh->build();
		}

		return CC_FERR_NO_ERROR;
	}
}